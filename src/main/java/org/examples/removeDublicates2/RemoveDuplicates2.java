package org.examples.removeDublicates2;

/**
 * Дан массив целых чисел nums, отсортированный по возрастанию. Нужно удалить дубликаты элементов in-place
 * (не создавая доп. структуры данных) так, чтобы каждый уникальный элемент появлялся не более двух раз.
 * Относительный порядок элементов должен остаться неизменным. Затем нужно вернуть количество уникальных элементов k.
 * Не выделяйте дополнительное место под дополнительный массив. <p>
 * Чтобы задание приняли, вам нужно сделать следующее:<p>
 * 1) Измените массив nums так, чтобы первые k элементов nums содержали элементы в том порядке,
 * в котором они присутствовали в nums изначально. Остальные элементы nums не важны, как и размер nums. <p>
 * 2) Верните К. <p/>
 * Пример 1: <p>
 * Вход: nums = [1,1,1,2,2,3] <p>
 * Выход: 5, nums = [1,1,2,2,3,_] <p>
 * Пример 2: <p>
 * Вход: nums = [0,0,1,1,1,1,2,3,3] <p>
 * Выход: 7, nums = [0,0,1,1,2,3,3,_,_] <p/>
 * Ограничения:  <p>
 * 1 <= nums.length <= 3 * 10^4 <p>
 * -10^4 <= nums[i] <= 10^4 <p>
 * nums отсортирован по возрастанию.
 */
public class RemoveDuplicates2 {

    public static int removeDuplicates2(int[] nums) {
        int index = 0;
        boolean hasDublicate = false;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == nums[index]) {
                if (!hasDublicate && (index != i)) {
                    // если нашли первый дубликат, то увеличиваем счётчик и помечаем, что дубликат уже найден
                    hasDublicate = true;
                    index++;
                    nums[index] = nums[i];
                }
            } else {
                // если элементы разные
                hasDublicate = false;
                index++;
                nums[index] = nums[i];
            }
        }
        return index + 1;
    }
}
